                '    runs_df,\n',
                '    task_name="Quadruped Walk",\n',
                '    max_step=100000,\n',
                '    y_max=1000,\n',
                ')\n',
                'fig.show()'
            ]
            cell['outputs'] = []
            cell['execution_count'] = None
            print(f"Updated cell {i}")
            break

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb', 'w') as f:
    json.dump(nb, f, indent=1)

print("Done")
EOF

python3 << 'EOF'
import json

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb') as f:
    nb = json.load(f)

# Find the plotting cell (cell 6, index 5)
for i, cell in enumerate(nb['cells']):
    if cell['cell_type'] == 'code':
        src = ''.join(cell['source'])
        if 'create_exploration_ablation_figure' in src and 'def create_exploration_ablation_figure' in src:
            cell['source'] = '''# Create the main figure
import plotly.graph_objects as go

def create_exploration_ablation_figure(
    df: pd.DataFrame,
    metric_key: str = "eval/episode_reward",
    task_name: str = "Quadruped Walk",
    max_step: int = 100000,
    y_max: int = 1000,
) -> go.Figure:
    """Create sample efficiency figure for exploration ablation.
    
    Shows: max (no noise) vs mean (with varying noise levels).
    Demonstrates that optimistic (max) head selection outperforms
    pessimistic (mean) with additive exploration noise.
    """
    fig = go.Figure()
    
    # Filter to max_step
    df = df[df["step"] <= max_step]
    
    # Group by condition and step, compute mean across seeds
    summary = (
        df.groupby(["head_reduce", "action_noise", "step"], as_index=False)
        .agg(mean_reward=(metric_key, "mean"))
    )
    
    # Define visual encodings - color encodes noise level
    noise_colors = {
        0.0: STYLE.COLORS[0],   # Cyan - no noise
        0.03: STYLE.COLORS[1],  # Pink
        0.1: STYLE.COLORS[2],   # Red
        0.3: STYLE.COLORS[3],   # Yellow
    }
    
    # Lines to plot:
    # - max with noise=0 (our method, solid cyan)
    # - mean with all noise levels (dashed, colored by noise)
    conditions_to_plot = [
        ("max", 0.0),    # Our method
        ("mean", 0.0),
        ("mean", 0.03),
        ("mean", 0.1),
        ("mean", 0.3),
    ]
    
    for head_reduce, action_noise in conditions_to_plot:
        mask = (summary["head_reduce"] == head_reduce) & (summary["action_noise"] == action_noise)
        group = summary[mask].sort_values("step")
        
        if group.empty:
            continue
        
        color = noise_colors.get(action_noise, STYLE.COLORS[4])
        dash = "solid" if head_reduce == "max" else "dash"
        
        # Create descriptive label
        if head_reduce == "max":
            label = "Maximum (σ=0)"
        else:
            label = f"Mean (σ={action_noise})"
        
        # Add mean line only (no std band)
        fig.add_trace(
            go.Scatter(
                x=group["step"],
                y=group["mean_reward"],
                mode="lines",
                name=label,
                line=dict(color=color, dash=dash, width=STYLE.LINE_WIDTH),
                hovertemplate=f"{label}<br>Step=%{{x}}<br>Reward=%{{y:.1f}}<extra></extra>",
            )
        )
    
    # Apply styling
    num_seeds = df["seed"].nunique()
    fig.update_layout(
        **STYLE.plotly_layout(
            title=f"{task_name} — Exploration Strategy Ablation (n={num_seeds} seeds)",
            xaxis_title="Environment Steps",
            yaxis_title="Evaluation Episode Reward",
            legend_title="Strategy",
        )
    )
    
    # Set axis ranges
    fig.update_xaxes(range=[0, max_step])
    fig.update_yaxes(range=[0, y_max])
    
    # Position legend outside the plot area on the right
    fig.update_layout(
        legend=dict(
            yanchor="top",
            y=0.98,
            xanchor="left",
            x=1.02,
            bgcolor="rgba(255,255,255,0.9)",
        ),
        margin=dict(r=150),  # Make room for legend on right side
    )
    
    return fig


fig = create_exploration_ablation_figure(
    runs_df,
    task_name="Quadruped Walk",
    max_step=100000,
    y_max=1000,
)
fig.show()'''
            cell['outputs'] = []
            cell['execution_count'] = None
            print(f"Updated cell {i}")
            break

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb', 'w') as f:
    json.dump(nb, f, indent=1)

print("Done - file saved")
EOF

python3 << 'EOF'
import json

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb') as f:
    nb = json.load(f)

# Find the plotting cell
for i, cell in enumerate(nb['cells']):
    if cell['cell_type'] == 'code':
        src = ''.join(cell['source'])
        if 'create_exploration_ablation_figure' in src and 'def create_exploration_ablation_figure' in src:
            cell['source'] = '''# Create the main figure
import plotly.graph_objects as go

def create_exploration_ablation_figure(
    df: pd.DataFrame,
    metric_key: str = "eval/episode_reward",
    task_name: str = "Quadruped Walk",
    max_step: int = 100000,
    y_max: int = 1000,
) -> go.Figure:
    """Create sample efficiency figure for exploration ablation.
    
    Shows: max (no noise) vs mean (with varying noise levels).
    Demonstrates that optimistic (max) head selection outperforms
    pessimistic (mean) with additive exploration noise.
    """
    fig = go.Figure()
    
    # Filter to max_step
    df = df[df["step"] <= max_step]
    
    # Group by condition and step, compute mean across seeds
    summary = (
        df.groupby(["head_reduce", "action_noise", "step"], as_index=False)
        .agg(mean_reward=(metric_key, "mean"))
    )
    
    # Define visual encodings - color encodes noise level
    noise_colors = {
        0.0: STYLE.COLORS[0],   # Cyan - no noise
        0.03: STYLE.COLORS[1],  # Pink
        0.1: STYLE.COLORS[2],   # Red
        0.3: STYLE.COLORS[3],   # Yellow
    }
    
    # Lines to plot:
    # - max with noise=0 (our method, solid cyan)
    # - mean with all noise levels (dashed, colored by noise)
    conditions_to_plot = [
        ("max", 0.0),    # Our method
        ("mean", 0.0),
        ("mean", 0.03),
        ("mean", 0.1),
        ("mean", 0.3),
    ]
    
    for head_reduce, action_noise in conditions_to_plot:
        mask = (summary["head_reduce"] == head_reduce) & (summary["action_noise"] == action_noise)
        group = summary[mask].sort_values("step")
        
        if group.empty:
            continue
        
        color = noise_colors.get(action_noise, STYLE.COLORS[4])
        dash = "solid" if head_reduce == "max" else "dash"
        
        # Create descriptive label
        if head_reduce == "max":
            label = "Maximum (σ=0)"
        else:
            label = f"Mean (σ={action_noise})"
        
        # Add mean line only (no std band)
        fig.add_trace(
            go.Scatter(
                x=group["step"],
                y=group["mean_reward"],
                mode="lines",
                name=label,
                line=dict(color=color, dash=dash, width=STYLE.LINE_WIDTH),
                hovertemplate=f"{label}<br>Step=%{{x}}<br>Reward=%{{y:.1f}}<extra></extra>",
            )
        )
    
    # Apply styling with larger fonts
    num_seeds = df["seed"].nunique()
    fig.update_layout(
        title=dict(
            text=f"{task_name} — Exploration Strategy Ablation (n={num_seeds} seeds)",
            font=dict(size=18),
        ),
        xaxis_title=dict(text="Environment Steps", font=dict(size=16)),
        yaxis_title=dict(text="Evaluation Episode Reward", font=dict(size=16)),
        font=dict(size=14),  # Base font size
        plot_bgcolor="white",
        paper_bgcolor="white",
    )
    
    # Set axis ranges and add grid lines
    fig.update_xaxes(
        range=[0, max_step],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=1,
        linecolor="black",
        tickfont=dict(size=14),
    )
    fig.update_yaxes(
        range=[0, y_max],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=1,
        linecolor="black",
        tickfont=dict(size=14),
    )
    
    # Position legend outside the plot area on the right
    fig.update_layout(
        legend=dict(
            title=dict(text="Strategy", font=dict(size=14)),
            yanchor="top",
            y=0.98,
            xanchor="left",
            x=1.02,
            bgcolor="rgba(255,255,255,0.9)",
            font=dict(size=13),
        ),
        margin=dict(r=150),  # Make room for legend on right side
    )
    
    return fig


fig = create_exploration_ablation_figure(
    runs_df,
    task_name="Quadruped Walk",
    max_step=100000,
    y_max=1000,
)
fig.show()'''
            cell['outputs'] = []
            cell['execution_count'] = None
            print(f"Updated cell {i}")
            break

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb', 'w') as f:
    json.dump(nb, f, indent=1)

print("Done - file saved with grid lines and larger fonts")
EOF

python3 << 'EOF'
import json

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb') as f:
    nb = json.load(f)

# Find the plotting cell
for i, cell in enumerate(nb['cells']):
    if cell['cell_type'] == 'code':
        src = ''.join(cell['source'])
        if 'create_exploration_ablation_figure' in src and 'def create_exploration_ablation_figure' in src:
            cell['source'] = '''# Create the main figure
import plotly.graph_objects as go

# ICML 2026 double-column format: figure will be ~half A4 width
# Need large fonts and thick lines for readability at reduced size
TITLE_FONT_SIZE = 24
AXIS_LABEL_FONT_SIZE = 22
TICK_FONT_SIZE = 20
LEGEND_FONT_SIZE = 18
LINE_WIDTH = 3.5

def create_exploration_ablation_figure(
    df: pd.DataFrame,
    metric_key: str = "eval/episode_reward",
    task_name: str = "Quadruped Walk",
    max_step: int = 100000,
    y_max: int = 1000,
) -> go.Figure:
    """Create sample efficiency figure for exploration ablation.
    
    Shows: max (no noise) vs mean (with varying noise levels).
    Demonstrates that optimistic (max) head selection outperforms
    pessimistic (mean) with additive exploration noise.
    """
    fig = go.Figure()
    
    # Filter to max_step
    df = df[df["step"] <= max_step]
    
    # Group by condition and step, compute mean across seeds
    summary = (
        df.groupby(["head_reduce", "action_noise", "step"], as_index=False)
        .agg(mean_reward=(metric_key, "mean"))
    )
    
    # Define visual encodings - color encodes noise level
    noise_colors = {
        0.0: STYLE.COLORS[0],   # Cyan - no noise
        0.03: STYLE.COLORS[1],  # Pink
        0.1: STYLE.COLORS[2],   # Red
        0.3: STYLE.COLORS[3],   # Yellow
    }
    
    # Lines to plot:
    # - max with noise=0 (our method, solid cyan)
    # - mean with all noise levels (dashed, colored by noise)
    conditions_to_plot = [
        ("max", 0.0),    # Our method
        ("mean", 0.0),
        ("mean", 0.03),
        ("mean", 0.1),
        ("mean", 0.3),
    ]
    
    for head_reduce, action_noise in conditions_to_plot:
        mask = (summary["head_reduce"] == head_reduce) & (summary["action_noise"] == action_noise)
        group = summary[mask].sort_values("step")
        
        if group.empty:
            continue
        
        color = noise_colors.get(action_noise, STYLE.COLORS[4])
        dash = "solid" if head_reduce == "max" else "dash"
        
        # Create descriptive label
        if head_reduce == "max":
            label = "Maximum (σ=0)"
        else:
            label = f"Mean (σ={action_noise})"
        
        # Add mean line only (no std band)
        fig.add_trace(
            go.Scatter(
                x=group["step"],
                y=group["mean_reward"],
                mode="lines",
                name=label,
                line=dict(color=color, dash=dash, width=LINE_WIDTH),
                hovertemplate=f"{label}<br>Step=%{{x}}<br>Reward=%{{y:.1f}}<extra></extra>",
            )
        )
    
    # Apply styling with publication-ready fonts
    num_seeds = df["seed"].nunique()
    fig.update_layout(
        title=dict(
            text=f"{task_name} — Exploration Strategy Ablation (n={num_seeds} seeds)",
            font=dict(size=TITLE_FONT_SIZE),
        ),
        xaxis_title=dict(text="Environment Steps", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        yaxis_title=dict(text="Evaluation Episode Reward", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        font=dict(size=TICK_FONT_SIZE),  # Base font size
        plot_bgcolor="white",
        paper_bgcolor="white",
    )
    
    # Set axis ranges and add grid lines
    fig.update_xaxes(
        range=[0, max_step],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    fig.update_yaxes(
        range=[0, y_max],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    
    # Position legend outside the plot area on the right
    fig.update_layout(
        legend=dict(
            title=dict(text="Strategy", font=dict(size=LEGEND_FONT_SIZE)),
            yanchor="top",
            y=0.98,
            xanchor="left",
            x=1.02,
            bgcolor="rgba(255,255,255,0.9)",
            font=dict(size=LEGEND_FONT_SIZE),
        ),
        margin=dict(r=180),  # More room for legend on right side
    )
    
    return fig


fig = create_exploration_ablation_figure(
    runs_df,
    task_name="Quadruped Walk",
    max_step=100000,
    y_max=1000,
)
fig.show()'''
            cell['outputs'] = []
            cell['execution_count'] = None
            print(f"Updated cell {i}")
            break

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb', 'w') as f:
    json.dump(nb, f, indent=1)

print("Done - larger fonts and thicker lines for ICML double-column format")
EOF

python3 << 'EOF'
import json

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb') as f:
    nb = json.load(f)

# Find the plotting cell
for i, cell in enumerate(nb['cells']):
    if cell['cell_type'] == 'code':
        src = ''.join(cell['source'])
        if 'create_exploration_ablation_figure' in src and 'def create_exploration_ablation_figure' in src:
            cell['source'] = '''# Create the main figure
import plotly.graph_objects as go

# ICML 2026 double-column format: figure will be ~half A4 width
# Need large fonts and thick lines for readability at reduced size
# Tall and narrow aspect ratio with legend at bottom
TITLE_FONT_SIZE = 24
AXIS_LABEL_FONT_SIZE = 22
TICK_FONT_SIZE = 20
LEGEND_FONT_SIZE = 18
LINE_WIDTH = 3.5
FIGURE_WIDTH = 550   # Narrower
FIGURE_HEIGHT = 550  # Taller

def create_exploration_ablation_figure(
    df: pd.DataFrame,
    metric_key: str = "eval/episode_reward",
    task_name: str = "Quadruped Walk",
    max_step: int = 100000,
    y_max: int = 1000,
) -> go.Figure:
    """Create sample efficiency figure for exploration ablation.
    
    Shows: max (no noise) vs mean (with varying noise levels).
    Demonstrates that optimistic (max) head selection outperforms
    pessimistic (mean) with additive exploration noise.
    """
    fig = go.Figure()
    
    # Filter to max_step
    df = df[df["step"] <= max_step]
    
    # Group by condition and step, compute mean across seeds
    summary = (
        df.groupby(["head_reduce", "action_noise", "step"], as_index=False)
        .agg(mean_reward=(metric_key, "mean"))
    )
    
    # Define visual encodings - color encodes noise level
    noise_colors = {
        0.0: STYLE.COLORS[0],   # Cyan - no noise
        0.03: STYLE.COLORS[1],  # Pink
        0.1: STYLE.COLORS[2],   # Red
        0.3: STYLE.COLORS[3],   # Yellow
    }
    
    # Lines to plot:
    # - max with noise=0 (our method, solid cyan)
    # - mean with all noise levels (dashed, colored by noise)
    conditions_to_plot = [
        ("max", 0.0),    # Our method
        ("mean", 0.0),
        ("mean", 0.03),
        ("mean", 0.1),
        ("mean", 0.3),
    ]
    
    for head_reduce, action_noise in conditions_to_plot:
        mask = (summary["head_reduce"] == head_reduce) & (summary["action_noise"] == action_noise)
        group = summary[mask].sort_values("step")
        
        if group.empty:
            continue
        
        color = noise_colors.get(action_noise, STYLE.COLORS[4])
        dash = "solid" if head_reduce == "max" else "dash"
        
        # Create descriptive label
        if head_reduce == "max":
            label = "Maximum (σ=0)"
        else:
            label = f"Mean (σ={action_noise})"
        
        # Add mean line only (no std band)
        fig.add_trace(
            go.Scatter(
                x=group["step"],
                y=group["mean_reward"],
                mode="lines",
                name=label,
                line=dict(color=color, dash=dash, width=LINE_WIDTH),
                hovertemplate=f"{label}<br>Step=%{{x}}<br>Reward=%{{y:.1f}}<extra></extra>",
            )
        )
    
    # Apply styling with publication-ready fonts
    num_seeds = df["seed"].nunique()
    fig.update_layout(
        title=dict(
            text=f"{task_name} — Exploration Strategy Ablation (n={num_seeds} seeds)",
            font=dict(size=TITLE_FONT_SIZE),
        ),
        xaxis_title=dict(text="Environment Steps", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        yaxis_title=dict(text="Evaluation Episode Reward", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        font=dict(size=TICK_FONT_SIZE),  # Base font size
        plot_bgcolor="white",
        paper_bgcolor="white",
        width=FIGURE_WIDTH,
        height=FIGURE_HEIGHT,
    )
    
    # Set axis ranges and add grid lines
    fig.update_xaxes(
        range=[0, max_step],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    fig.update_yaxes(
        range=[0, y_max],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    
    # Position legend at the bottom, horizontal orientation
    fig.update_layout(
        legend=dict(
            title=dict(text="Strategy", font=dict(size=LEGEND_FONT_SIZE)),
            orientation="h",
            yanchor="top",
            y=-0.15,
            xanchor="center",
            x=0.5,
            bgcolor="rgba(255,255,255,0.9)",
            font=dict(size=LEGEND_FONT_SIZE),
        ),
        margin=dict(b=120),  # Room for legend at bottom
    )
    
    return fig


fig = create_exploration_ablation_figure(
    runs_df,
    task_name="Quadruped Walk",
    max_step=100000,
    y_max=1000,
)
fig.show()'''
            cell['outputs'] = []
            cell['execution_count'] = None
            print(f"Updated cell {i}")
            break

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb', 'w') as f:
    json.dump(nb, f, indent=1)

print("Done - taller/narrower figure with legend at bottom")
EOF

python3 << 'EOF'
import json

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb') as f:
    nb = json.load(f)

# Find the plotting cell
for i, cell in enumerate(nb['cells']):
    if cell['cell_type'] == 'code':
        src = ''.join(cell['source'])
        if 'create_exploration_ablation_figure' in src and 'def create_exploration_ablation_figure' in src:
            cell['source'] = '''# Create the main figure
import plotly.graph_objects as go

# ICML 2026 double-column format: figure will be ~half A4 width
# Need large fonts and thick lines for readability at reduced size
# Tall and narrow aspect ratio with legend at bottom
TITLE_FONT_SIZE = 24
AXIS_LABEL_FONT_SIZE = 22
TICK_FONT_SIZE = 20
LEGEND_FONT_SIZE = 16
LINE_WIDTH = 3.5
FIGURE_WIDTH = 550   # Narrower
FIGURE_HEIGHT = 600  # Taller to fit title and legend

def create_exploration_ablation_figure(
    df: pd.DataFrame,
    metric_key: str = "eval/episode_reward",
    task_name: str = "Quadruped Walk",
    max_step: int = 100000,
    y_max: int = 1000,
) -> go.Figure:
    """Create sample efficiency figure for exploration ablation.
    
    Shows: max (no noise) vs mean (with varying noise levels).
    Demonstrates that optimistic (max) head selection outperforms
    pessimistic (mean) with additive exploration noise.
    """
    fig = go.Figure()
    
    # Filter to max_step
    df = df[df["step"] <= max_step]
    
    # Group by condition and step, compute mean across seeds
    summary = (
        df.groupby(["head_reduce", "action_noise", "step"], as_index=False)
        .agg(mean_reward=(metric_key, "mean"))
    )
    
    # Define visual encodings - color encodes noise level
    noise_colors = {
        0.0: STYLE.COLORS[0],   # Cyan - no noise
        0.03: STYLE.COLORS[1],  # Pink
        0.1: STYLE.COLORS[2],   # Red
        0.3: STYLE.COLORS[3],   # Yellow
    }
    
    # Lines to plot:
    # - max with noise=0 (our method, solid cyan)
    # - mean with all noise levels (dashed, colored by noise)
    conditions_to_plot = [
        ("max", 0.0),    # Our method
        ("mean", 0.0),
        ("mean", 0.03),
        ("mean", 0.1),
        ("mean", 0.3),
    ]
    
    for head_reduce, action_noise in conditions_to_plot:
        mask = (summary["head_reduce"] == head_reduce) & (summary["action_noise"] == action_noise)
        group = summary[mask].sort_values("step")
        
        if group.empty:
            continue
        
        color = noise_colors.get(action_noise, STYLE.COLORS[4])
        dash = "solid" if head_reduce == "max" else "dash"
        
        # Create descriptive label
        if head_reduce == "max":
            label = "Maximum (σ=0)"
        else:
            label = f"Mean (σ={action_noise})"
        
        # Add mean line only (no std band)
        fig.add_trace(
            go.Scatter(
                x=group["step"],
                y=group["mean_reward"],
                mode="lines",
                name=label,
                line=dict(color=color, dash=dash, width=LINE_WIDTH),
                hovertemplate=f"{label}<br>Step=%{{x}}<br>Reward=%{{y:.1f}}<extra></extra>",
            )
        )
    
    # Apply styling with publication-ready fonts
    num_seeds = df["seed"].nunique()
    fig.update_layout(
        title=dict(
            text=f"{task_name} — Exploration Strategy Ablation (n={num_seeds} seeds)",
            font=dict(size=TITLE_FONT_SIZE),
            y=0.98,  # Position title higher
            x=0.5,
            xanchor="center",
        ),
        xaxis_title=dict(text="Environment Steps", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        yaxis_title=dict(text="Evaluation Episode Reward", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        font=dict(size=TICK_FONT_SIZE),  # Base font size
        plot_bgcolor="white",
        paper_bgcolor="white",
        width=FIGURE_WIDTH,
        height=FIGURE_HEIGHT,
    )
    
    # Set axis ranges and add grid lines
    fig.update_xaxes(
        range=[0, max_step],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    fig.update_yaxes(
        range=[0, y_max],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    
    # Position legend at the bottom in a grid (3 on top, 2 below)
    # Use entrywidth to control items per row
    fig.update_layout(
        legend=dict(
            orientation="h",
            yanchor="top",
            y=-0.22,  # Lower to avoid overlap with x-axis label
            xanchor="center",
            x=0.5,
            bgcolor="rgba(255,255,255,0.9)",
            font=dict(size=LEGEND_FONT_SIZE),
            entrywidth=150,  # Controls wrapping - 3 items then 2
            entrywidthmode="pixels",
        ),
        margin=dict(t=60, b=140),  # Top margin for title, bottom for legend
    )
    
    return fig


fig = create_exploration_ablation_figure(
    runs_df,
    task_name="Quadruped Walk",
    max_step=100000,
    y_max=1000,
)
fig.show()'''
            cell['outputs'] = []
            cell['execution_count'] = None
            print(f"Updated cell {i}")
            break

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb', 'w') as f:
    json.dump(nb, f, indent=1)

print("Done - legend grid layout, title not cut off, no overlap")
EOF

python3 << 'EOF'
import json

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb') as f:
    nb = json.load(f)

# Find the plotting cell
for i, cell in enumerate(nb['cells']):
    if cell['cell_type'] == 'code':
        src = ''.join(cell['source'])
        if 'create_exploration_ablation_figure' in src and 'def create_exploration_ablation_figure' in src:
            cell['source'] = '''# Create the main figure
import plotly.graph_objects as go

# ICML 2026 double-column format: figure will be ~half A4 width
# Need large fonts and thick lines for readability at reduced size
# Tall and narrow aspect ratio with legend at bottom
TITLE_FONT_SIZE = 22
SUBTITLE_FONT_SIZE = 18
AXIS_LABEL_FONT_SIZE = 22
TICK_FONT_SIZE = 20
LEGEND_FONT_SIZE = 16
LINE_WIDTH = 3.5
FIGURE_WIDTH = 550   # Narrower
FIGURE_HEIGHT = 620  # Taller to fit two-line title and legend

def create_exploration_ablation_figure(
    df: pd.DataFrame,
    metric_key: str = "eval/episode_reward",
    task_name: str = "Quadruped Walk",
    max_step: int = 100000,
    y_max: int = 1000,
) -> go.Figure:
    """Create sample efficiency figure for exploration ablation.
    
    Shows: max (no noise) vs mean (with varying noise levels).
    Demonstrates that optimistic (max) head selection outperforms
    pessimistic (mean) with additive exploration noise.
    """
    fig = go.Figure()
    
    # Filter to max_step
    df = df[df["step"] <= max_step]
    
    # Group by condition and step, compute mean across seeds
    summary = (
        df.groupby(["head_reduce", "action_noise", "step"], as_index=False)
        .agg(mean_reward=(metric_key, "mean"))
    )
    
    # Define visual encodings - color encodes noise level
    noise_colors = {
        0.0: STYLE.COLORS[0],   # Cyan - no noise
        0.03: STYLE.COLORS[1],  # Pink
        0.1: STYLE.COLORS[2],   # Red
        0.3: STYLE.COLORS[3],   # Yellow
    }
    
    # Lines to plot:
    # - max with noise=0 (our method, solid cyan)
    # - mean with all noise levels (dashed, colored by noise)
    conditions_to_plot = [
        ("max", 0.0),    # Our method
        ("mean", 0.0),
        ("mean", 0.03),
        ("mean", 0.1),
        ("mean", 0.3),
    ]
    
    for head_reduce, action_noise in conditions_to_plot:
        mask = (summary["head_reduce"] == head_reduce) & (summary["action_noise"] == action_noise)
        group = summary[mask].sort_values("step")
        
        if group.empty:
            continue
        
        color = noise_colors.get(action_noise, STYLE.COLORS[4])
        dash = "solid" if head_reduce == "max" else "dash"
        
        # Create descriptive label
        if head_reduce == "max":
            label = "Maximum (σ=0)"
        else:
            label = f"Mean (σ={action_noise})"
        
        # Add mean line only (no std band)
        fig.add_trace(
            go.Scatter(
                x=group["step"],
                y=group["mean_reward"],
                mode="lines",
                name=label,
                line=dict(color=color, dash=dash, width=LINE_WIDTH),
                hovertemplate=f"{label}<br>Step=%{{x}}<br>Reward=%{{y:.1f}}<extra></extra>",
            )
        )
    
    # Apply styling with publication-ready fonts
    num_seeds = df["seed"].nunique()
    
    # Two-line title: main title + subtitle with task/seeds
    title_text = f"Exploration Strategy Ablation<br><span style='font-size:{SUBTITLE_FONT_SIZE}px'>{task_name} ({num_seeds} seeds)</span>"
    
    fig.update_layout(
        title=dict(
            text=title_text,
            font=dict(size=TITLE_FONT_SIZE),
            y=0.96,
            x=0.5,
            xanchor="center",
        ),
        xaxis_title=dict(text="Environment Steps", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        yaxis_title=dict(text="Evaluation Episode Reward", font=dict(size=AXIS_LABEL_FONT_SIZE)),
        font=dict(size=TICK_FONT_SIZE),  # Base font size
        plot_bgcolor="white",
        paper_bgcolor="white",
        width=FIGURE_WIDTH,
        height=FIGURE_HEIGHT,
    )
    
    # Set axis ranges and add grid lines
    fig.update_xaxes(
        range=[0, max_step],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    fig.update_yaxes(
        range=[0, y_max],
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(200,200,200,0.5)",
        showline=True,
        linewidth=2,
        linecolor="black",
        tickfont=dict(size=TICK_FONT_SIZE),
    )
    
    # Position legend at the bottom in a grid (3 on top, 2 below)
    fig.update_layout(
        legend=dict(
            orientation="h",
            yanchor="top",
            y=-0.22,
            xanchor="center",
            x=0.5,
            bgcolor="rgba(255,255,255,0.9)",
            font=dict(size=LEGEND_FONT_SIZE),
            entrywidth=150,
            entrywidthmode="pixels",
        ),
        margin=dict(t=80, b=140),  # Top margin for two-line title
    )
    
    return fig


fig = create_exploration_ablation_figure(
    runs_df,
    task_name="Quadruped Walk",
    max_step=100000,
    y_max=1000,
)
fig.show()'''
            cell['outputs'] = []
            cell['execution_count'] = None
            print(f"Updated cell {i}")
            break

with open('/projects/prjs0951/Thomas/Thesis/RL_weather/tdmpc2-with-return-based-auxiliary-tasks/analysis/notebooks/07_optimistic_exploration_ablation.ipynb', 'w') as f:
    json.dump(nb, f, indent=1)

print("Done - two-line title: Exploration Strategy Ablation / Quadruped Walk (10 seeds)")
EOF

conda activate carlo
 /usr/bin/env /home/cmeo/.conda/envs/carlo/bin/python /gpfs/home1/cmeo/.cursor-server/extensions/ms-python.python-2023.6.0/pythonFiles/lib/python/debugpy/adapter/../../debugpy/launcher 37231 -- /home/cmeo/Carlo/process_data/compare.py 
 cd /home/cmeo/Carlo/process_data ; /usr/bin/env /home/cmeo/.conda/envs/carlo/bin/python /gpfs/home1/cmeo/.cursor-server/extensions/ms-python.python-2023.6.0/pythonFiles/lib/python/debugpy/adapter/../../debugpy/launcher 42895 -- /home/cmeo/Carlo/process_data/compare.py 
conda activate carlo
/home/cmeo/.conda/envs/carlo/bin/python /home/cmeo/Carlo/process_data/compare.py
